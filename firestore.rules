rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Waitlist collection rules
    match /waitlist/{document} {
      // Allow anyone to create waitlist entries (public signup)
      // Enhanced security with stricter validation
      allow create: if 
        request.auth == null && // Only allow unauthenticated requests
        request.resource.data.email is string &&
        request.resource.data.email.matches('^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$') &&
        request.resource.data.email.size() <= 254 &&
        request.resource.data.status == 'pending' &&
        (request.resource.data.name == null || 
         (request.resource.data.name is string && 
          request.resource.data.name.size() <= 100 &&
          !request.resource.data.name.matches('.*[<>].*'))) &&
        (request.resource.data.language == null || 
         request.resource.data.language in ['en', 'pt']) &&
        request.resource.data.createdAt is timestamp &&
        request.resource.data.comms is map &&
        request.resource.data.dedupeKey is string &&
        (request.resource.data.captchaToken == null || 
         request.resource.data.captchaToken is string) &&
        request.resource.data.captchaVerified is bool;
      
      // Allow reading for duplicate email checking (public read for email validation)
      // This is needed for the duplicate email check functionality
      allow read: if true;
      
      // Prevent updates and deletes from client
      allow update, delete: if false;
    }
    
    // Email events collection - server only
    match /email_events/{document} {
      allow read, write: if false;
    }
    
    // Dead letter queue - server only
    match /email_dlq/{document} {
      allow read, write: if false;
    }
    
    // User profiles collection - role-based access for admin console
    match /users/{userId} {
      // Allow users to read their own data, or admins to read all users
      allow read: if request.auth != null && 
        (request.auth.uid == userId || hasAnyRole(['admin', 'superadmin', 'support']));
      
      // Allow users to create/update their own data (roles are server-managed)
      allow create: if request.auth != null && 
        request.auth.uid == userId &&
        !('roles' in request.resource.data) && // Prevent client from setting roles
        request.resource.data.uid == userId &&
        request.resource.data.email is string;
      
      allow update: if request.auth != null && 
        request.auth.uid == userId &&
        !('roles' in request.resource.data) && // Prevent client from modifying roles
        (!('roles' in resource.data) || request.resource.data.roles == resource.data.roles); // Keep existing roles unchanged
      
      // Prevent user deletion from client
      allow delete: if false;
    }
    
    // Admin collections - role-based access using custom claims
    match /admin/{document} {
      // Feature flags - readable by support+, writable by admin+
      allow read: if request.auth != null && 
        hasAnyRole(['support', 'editor', 'viewer', 'admin', 'superadmin']);
      allow write: if request.auth != null && 
        hasAnyRole(['admin', 'superadmin']);
      
      // Subcollections for audit logs
      match /auditLogs/{logDocument} {
        allow read: if request.auth != null && 
          hasAnyRole(['support', 'admin', 'superadmin']);
        allow write: if false; // Only server can write audit logs
        
        match /entries/{entryId} {
          allow read: if request.auth != null && 
            hasAnyRole(['support', 'admin', 'superadmin']);
          allow write: if false; // Only server can write audit logs
        }
      }
    }
    
    // Helper function to check if user has any of the required roles
    function hasAnyRole(roles) {
      return request.auth != null && 
        request.auth.token.roles != null &&
        roles.hasAny(request.auth.token.roles);
    }
    
    // Default deny rule for any unmatched paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
